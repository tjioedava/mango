## Assignment 6

1. Benefits of JavaScript in web application
    As a turing complete programming language, JavaScript allows interactivity in web pages since the document can be manipulated in extent as far as the programmer's creativity. This makes web pages more 'alive', aesthethic, and engaging. JavaScript also streches HTML element ability to perform operations, not just a mere HTML-built-in form submission for instance, but also DOM modification by element-click trigger, url redirections, and asynchronous requests in the client side.
2. Functionality of `await` keyword preceding `fetch()` API call.
    `await` keyword makes the execution of next instructions halted, waiting for the promise yield by `fetch()` API call to be resolved first to either HTTP response or error. `await` also makes the return type the promise result instead of the promise itself. Therefore, `await` ensures that the `fetch()` return is available as the result instead of a promise, making the execution run in sequential fashion. In other words, `await` makes asynchronous executions in an asynchronous function run in synchronous style.

    If we don't use `await` keyword, the return type of `fetch()` would be in form of promise object, not the result, and the next instruction will immediately be executed after the promise is created. The result of the promise cannot be immediately used in the next instruction. One needs to add listener when the promise is resolved by using `then()` method that performs handling function that uses the result.

3. Why do we need to use `csrf_exempt` decorator for AJAX POST request view handler?
    In the tutorial, in an immediate sense we need to use the `csrf_exempt` decorator so that django won't demand the CSRF token in the AJAX request. This sense is falsely generated by the assumption that we cannot embed the CSRF token in user's cookies when fetching POST request. However, in fact, we can simply put the CSRF token in the HTML page, for instance in meta tag attribute, retrieve it in the script and pass it in the POST request through `fetch()`. This approach is much more safe to ensure that the AJAX POST request can only be sent from trustworthy source, under our consent.

4. Why data sanitazion needs to be implemented in the back-end as well, not in the front-end only?
    Input fields security in front-end can easily be bypassed or manipulated so that malicious users can input whatever text that can harm the web application and the database. Therefore, double sanization needs to be implemented, such that the sent information needs to be sanitized before they are handled by appropriate view.

    Regarding the tutorial, preventing malicious input using input sanitazion is not enough, since malicious input might have been inputted before the input sanitazion is implemented, thus we need to manually clean the database or sanitize the data from the database when displaying it in the pages.

5. How to implement each checkpoint in step-by-step manner?
    1. Change `product-card` code to support AJAX `GET`
        Instead of displaying the `product-card.html` components in the home page directly, we will dynamically generate them through AJAX `GET` by manipulating the DOM using script, embedding the content of `product-card.html` in container `innerHTML`. Wrap these whole operations inside `refreshProducts` function.
    2. Implement data retrieval through AJAX `GET`
        Use `fetch()` API to make a `GET` request, that requests `show-products` in JSON format, which yields all the products of current user. It will return a promise and use `then()` for a follow up actions that will iterate through the products to create a string equivalent of the codes of `product-card.html`, which will be embedded in product container's `innerHTML`.
    3. Create a modal containing form to create a product
        Create a modal using div element with `hidden` position that contains input tags and a button. Create a button using div element in the home page, that has click event listener that will set the position of the modal to `fixed`, effectively showing the modal. The button inside the modal will be bound by a function that will retrieve the inputted value in the input tags such as name, price, and description, and include it in the `fetch()` `POST` request body. When the response of the request is successfull, hide the modal, clear the input, and call `refreshProducts` function.
    4. Create the server-side handler for the AJAX `POST` request
        One can do that by simply defining the URL pattern that will be bound to appropriate view that allows only POST request, and retrive the inputted values to be used as product creation parameters.
